<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=device-width">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Pixel Socket - to stream your cam in pixelated way</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;

        }

        .view {
            position: relative;

        }

        .select {
            margin: 10px;

        }

        .color {
            width: 100%;
            height: 20px;
            border-radius: 0;
            background: #000;
        }

        video {
            opacity: 0;
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
            width: 100%;
            height: 100%;
        }

        canvas {
            margin: 30px auto;
            display: block;
            width: 100%;
            max-width: 640px;

        }

        .clear {
            clear: both;
            content: ' ';
            display: block;
        }

        .select-source {
            display: none;
        }
    </style>
</head>

<body>



    <div id="container">

        <!-- <div class="color"></div> -->


        <div class="select-source">
            <label for="audioSource">Audio source: </label><select id="audioSource"></select>
        </div>

        <div class="select-source">
            <label for="videoSource">Video source: </label><select id="videoSource"></select>
        </div>

        <div class="view">

            <div class=" video">
                <video muted autoplay></video>
            </div>

            <div class="canvas">
                <canvas id="render"></canvas>

            </div>


            <div class="clear"></div>
        </div>


    </div>

    <script>

        var videoElement = document.querySelector('video');
        var audioSelect = document.querySelector('select#audioSource');
        var videoSelect = document.querySelector('select#videoSource');



        audioSelect.onchange = getStream;
        videoSelect.onchange = getStream;






        function gotDevices(deviceInfos) {
            for (var i = 0; i !== deviceInfos.length; ++i) {
                var deviceInfo = deviceInfos[i];
                var option = document.createElement('option');
                option.value = deviceInfo.deviceId;
                if (deviceInfo.kind === 'audioinput') {
                    option.text = deviceInfo.label ||
                        'microphone ' + (audioSelect.length + 1);
                    audioSelect.appendChild(option);
                } else if (deviceInfo.kind === 'videoinput') {
                    option.text = deviceInfo.label || 'camera ' +
                        (videoSelect.length + 1);
                    videoSelect.appendChild(option);
                } else {
                    console.log('Found one other kind of source/device: ', deviceInfo);
                }
            }
        }

        function getStream() {
            if (window.stream) {
                window.stream.getTracks().forEach(function (track) {
                    track.stop();
                });
            }

            var constraints = {
                // audio: {
                //     deviceId: { exact: audioSelect.value }
                // },
                audio: false,
                video: {
                    deviceId: { exact: videoSelect.value }
                }
            };

            navigator.mediaDevices.getUserMedia(constraints).
                then(gotStream).catch(handleError);
        }


        // document.querySelector('canvas').onmousemove = (ev) => {

        //     const frameCanvas = document.createElement('canvas');
        //     frameCanvas.width = videoElement.videoWidth;
        //     frameCanvas.height = videoElement.videoHeight;
        //     const frameCanvasContext = frameCanvas.getContext('2d');

        //     frameCanvasContext.drawImage(videoElement, 0, 0);

        //     console.log(ev.clientY, ev.clientX)


        //     let frameImage;

        //     frameImage = (frameCanvasContext.getImageData(0, 0, frameCanvas.width, frameCanvas.height))

        //     let index = ((ev.clientY * frameCanvas.width) * 3 + ev.clientX * 3);
        //     document.querySelector('.color').setAttribute('style',
        //         `background:rgb(${frameImage.data[index]},${frameImage.data[index + 1]},${frameImage.data[index + 2]})`)

        // };

        let squareWidth = 10;
        let validPixelRate = 50;
        const ws =
            new WebSocket(`${location.protocol.replace('http', 'ws')}//${location.hostname}:${location.port}/socket_host`);




        ws.onopen = () => {
            console.log('ws open');
            navigator.mediaDevices.enumerateDevices()
            .then(gotDevices).then(getStream).catch(handleError);

        }
        ws.onerror = (error) => {
            console.log('ws error', error);

        }

        function gotStream(stream) {
            window.stream = stream; // make stream available to console
            videoElement.srcObject = stream;





            const draw = () => {

                const frameCanvas = document.createElement('canvas');
                const canvas = document.querySelector('canvas');
                frameCanvas.width = canvas.width = videoElement.videoWidth;
                frameCanvas.height = canvas.height = videoElement.videoHeight;
                const frameCanvasContext = frameCanvas.getContext('2d');
                const canvasContext = canvas.getContext('2d');

                frameCanvasContext.drawImage(videoElement, 0, 0);
                let frameImage;

                frameImage = (frameCanvasContext.getImageData(0, 0, canvas.width, canvas.height))


                const data = frameImage.data;
                const roundTo = 100;


                for (var i = 0; i < data.length; i += 4) {

                    // data[i] = Math.ceil(data[i] / roundTo) * roundTo; // Invert Red
                    // data[i + 1] = Math.ceil(data[i + 1] / roundTo) * roundTo // Invert Green
                    // data[i + 2] = Math.ceil(data[i + 2] / roundTo) * roundTo; // Invert Blue

                    // data[i] = data[i] ^ 255; // Invert Red
                    // data[i + 1] = data[i + 1] ^ 255; // Invert Green
                    // data[i + 2] = data[i + 2] ^ 255; // Invert Blue

                    var redValue = data[i];
                    var greenValue = data[i + 1];
                    var blueValue = data[i + 2];




                    if (redValue > greenValue - 10 && redValue > blueValue + 0) {

                        data[i] = 0;
                        data[i + 1] = 0;
                        data[i + 2] = 0;

                    } else {

                        data[i] = 255; // Invert Red
                        data[i + 1] = 255; // Invert Green
                        data[i + 2] = 255; // Invert Blue

                    }

                    if (greenValue > blueValue) {
                        data[i] = 255; // Invert Red
                        data[i + 1] = 255; // Invert Green
                        data[i + 2] = 255; // Invert Bluet
                    }

                    // const output = net.run({ r: data[i], g: data[i + 1], b: data[i + 2] });  // { white: 0.81, black: 0.18 }
                    // if (output.white < output.black) {
                    //     data[i] = 255; // Invert Red
                    //     data[i + 1] = 255; // Invert Green
                    //     data[i + 2] = 255; // Invert Blue
                    // }

                }



                canvasContext.putImageData(frameImage, 0, 0)


                const clearTrashes = (sw, pixelRate) => {
                    for (let sr = 0; sr < Math.ceil(canvas.height / sw); sr++) {

                        for (let sc = 0; sc < Math.ceil(canvas.width / sw); sc++) {

                            const square = canvasContext.getImageData(sc * sw, sr * sw, sw, sw);

                            //                    console.log(square.data.filter(p => p != 255).length)

                            if (square.data.filter(p => p != 255).length < pixelRate) {

                                for (let si = 0; si < square.data.length; si++) {
                                    square.data[si] = 255;
                                }
                                canvasContext.putImageData(square, sc * sw, sr * sw)
                            } else {

                            }
                        }
                    }
                }

               //  clearTrashes(squareWidth, validPixelRate);
            //  clearTrashes(32, 500);
                // clearTrashes(64, 1500);

                const renderImage = canvasContext.getImageData(0, 0, canvas.width, canvas.height);

                // const fileReader = new FileReader();
                // fileReader.readAsDataURL(new Blob(renderImage.data));
                // fileReader.onloadend = ((ev) => {

                // });

                if (ws.OPEN && !ws.CONNECTING)
                    ws.send(canvas.toDataURL('image/png'));

                setTimeout(() => {
                    draw();
                }, 500)
            }


            setTimeout(() => {
                draw();


            }, 500);

        }

        function handleError(error) {
            console.log('Error: ', error);
        }


    </script>



</body>

</html>